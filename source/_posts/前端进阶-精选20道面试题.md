---
title: 前端进阶 精选20道面试题
date: 2020-03-07 14:43:51
tags: [web]
categories: [前端进阶]
---

### 1. new 的实现原理

<!-- more -->

1. 新建一个空对象  let newObj = {}
2. 修改对象的原型: 把新对象的 `__proto__` 指向构造函数的 `prototype` 属性
3. 改变 this 指向，并执行原来构造函数里边的内容
4. 返回对象里边的内容
```js
function _new () {
  let obj = {}
  let Constructor = [].shift.call(arguments);
  obj.__proto__ = Constructor.prototype;
  let res = Constructor.apply(obj, arguments);
  return res === 'object' ? res : obj;
}
```

### 2. 如何正确判断一 this 指向

分析好上下文：**谁调用指向谁**

分四种情况：new, 显示，隐式，默认

参考这里： [this指向](/3915840815.html)

### 3. 深拷贝和浅拷贝的区别是什么？ 实现一个深拷贝

浅拷贝一般指用来拷贝栈内存上的东西，而深拷贝一般是指用来拷贝堆内存上的东西

这是我个人的理解， 为啥这么说呢 ？ 

浅拷贝：创建一个新对象，这个对象有着原始对象属性值的一份精确拷贝。如果属性是基本类型，拷贝的就是基本类型的值，如果属性是引用类型，拷贝的就是内存地址 ，所以如果其中一个对象改变了这个地址，就会影响到另一个对象。

深拷贝：将一个对象从内存中完整的拷贝一份出来,从堆内存中开辟一个新的区域存放新对象,且修改新对象不会影响原对象

之前有文章介绍过基本类型是存在栈内存上的，而引用类型来说，对象的属性是保存在栈内存中的，属性对应的值是保存在堆内存中的, 同时，栈内存上也保存着该属性的值所在的堆内存的地址。

所以我们可以这样去理解，浅拷贝是栈内存上的拷贝，而深拷贝是堆内存上的拷贝.

首先我们要明月一个前提：

**只有对象里嵌套对象的情况下,才会根据需求讨论,我们要深拷贝还是浅拷贝。**

##### 浅拷贝实现：
1. `Oject.assign()`
```js
let ahui = {
  name: "ahui",
  age: "18",
  city: ["泰国","新加坡","印度尼西亚"],
  sayname: function () {
    return this.name
  },
  saycity: function () {
    return this.city
  }
}

// let angeli = Object.assign({}, ahui) // 这样实现深拷贝
let angeli = Object.assign(ahui, {}) // 这样实现浅拷贝

angeli.name = "angeli"

console.log(ahui.sayname()) // angeli
console.log(angeli.sayname()) // angeli

angeli.city = ["深圳","娄底"]

console.log(ahui.saycity()) // ["深圳","娄底"]
console.log(angeli.saycity()) // ["深圳","娄底"]
```

Object.assign() 方法用于将所有可枚举属性的值从一个或多个源对象复制到目标对象。**它将返回目标对象。**

关于 `Object.assign()`这个方法是深拷贝还是浅拷贝的时候，是分情况的。

假如源对象的属性值是一个对象的引用，那么它也只指向那个引用。也就是说，如果对象的属性值为简单类型（如`string`， `number`），通过`Object.assign({},srcObj);`得到的新对象为深拷贝；如果属性值为对象或其它引用类型，那对于这个对象而言其实是浅拷贝的。

##### 深拷贝实现

1. 可以使用各种第三方的库， 我常用 [lodash 的 cloneDeep](https://www.lodashjs.com/docs/lodash.cloneDeep)
2. 通过判断加递归实现深拷贝
```js
function cloneDeep(obj) {
  if (typeof obj === 'object') {
    let tempObj = Array.isArray(obj) ? [] : {}

    for (key in obj) {
      // 意思就是__proto__上面的属性,我不拷贝
      if (obj.hasOwnProperty(key))  {
        if (typeof obj[key] === 'object') {
          tempObj[key] = cloneDeep(obj[key])
        } else {
          tempObj[key] = obj[key]
        }
      }
    }
    
    return tempObj;
  }
  return obj
}


let ahui = {
  name: "ahui",
  age: "18",
  city: ["泰国","新加坡","印度尼西亚"],
  sayname: function () {
    return this.name
  },
  saycity: function () {
    return this.city
  }
}

let angeli = cloneDeep(ahui) // 这样实现深拷贝

angeli.name = "angeli"

console.log(ahui.sayname()) // ahui
console.log(angeli.sayname()) // angeli

angeli.city = ["深圳","娄底"]

console.log(ahui.saycity()) // ["泰国","新加坡","印度尼西亚"]
console.log(angeli.saycity()) // ["深圳","娄底"]
```

### 4. call/apply 的实现原理是什么？

`call` 跟 `apply` 的功能是相同的，都是 改变 `this` 的执行，并立马执行函数。区别在于传参方式不同：
> `func.call(thisArg,arg1,arg2,...)`：第一个参数是 `this` 指向的对象，其它参数依次传入。
> `func.apply(thisArg,[argsArray])`：第一个参数是 `this` 指向的对象，第二个参数是数组或类数组。

**`call`**

```js
// 先使用call 试一下
let person = {
  name: "person",
  sayname: function () {
    return this.name
  }
}

console.log(person.sayname()) // person
let ahui = { name: "ahui" };
console.log(person.sayname.call(ahui)) // ahui

// 下边我们自己实现一个 call
Function.prototype.imitateCall = function(context = window) {
  // 这里的 this， 是指原来对象里的方法， 比如下边的 person.sayname
  context.fn = this 
  // slice(start, end) 方法可从已有的数组中返回选定的元素。
  let args = [...arguments].slice(1)
  // 执行调用的函数， 比如下边的 sayname
  let result = context.fn(...args)
  // 删除函数调用，要不然会改变 context
  delete context.fn
  // 返回执行结果
  return result
}

console.log(person.sayname.imitateCall(ahui)) // ahui

// 再试一下有参数的例子

let Boy = function (name, age) {
  this.name = name
  this.age = age
  this.sayInfo = function(name, age) {
    return `my name is: ${name}, my age: ${age}`
  }
}

angeli = new Boy("angeli", 18)

console.log(angeli.sayInfo("angeli", 18)) // 1 my name is: angeli, my age: 18

let huihui = {}

console.log(angeli.sayInfo.call(huihui, "huihui", 28)) // 2 my name is: huihui, my age: 28

console.log(angeli.sayInfo.imitateCall(huihui, "pengpeng", 38)) // 3 "my name is: pengpeng, my age: 38"

```

### 5. 柯里化函数实现

函数柯里化是把接受多个参数的函数变换成接受一个单一参数（最初函数的第一个参数）的函数，并且返回接受余下的参数而且返回结果的新函数的技术。


```js
function add() {
  var _args = Array.prototype.slice.call(arguments)

  // 这个东西的作用就是利用闭包函数的特性把每次执行之后的参数者保存好，再依次放入数组中
  var _adder = function () {
    _args.push(...arguments);
    return _adder;
  }

  // 在 js 中，每次打印的时候，都会调用 toString 函数，所以，重写这里的 toSting 等函数执行完就会进行打印的时候， 就会调用里边的求和函数
  // reduce 方法的参数为函数，且不可以少； array.reduce(function(total, currentValue, currentIndex, arr), initialValue)
  _adder.toString = () => _args.reduce((total, num) => total + num)

  return _adder;
}
add(1, 2, 3)(4)(5)




```



参考地址： 

[**原文地址**>>](https://mp.weixin.qq.com/s/JIgaDqPzF9Nyt4HWXCuh9Q)

1. [js 基本类型与引用类型的区别](https://www.imooc.com/article/67538)
2. [一篇文章彻底说清JS的深拷贝/浅拷贝](https://segmentfault.com/a/1190000012828382)
3. [Object.assign 是浅拷贝还是深拷贝](https://www.jianshu.com/p/1b212581a8d5)
4. [详解JS函数柯里化](https://www.jianshu.com/p/2975c25e4d71)